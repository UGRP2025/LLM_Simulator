import numpy as np
import pandas as pd
from dataclasses import dataclass
from scipy.interpolate import splprep, splev
from car_control.planner_utils import find_closest_waypoint

@dataclass
class Lane:
    waypoints: np.ndarray
    meta: dict

@dataclass
class Lanes:
    center: Lane
    inner: Lane
    outer: Lane

def _calculate_lane_metadata(waypoints: np.ndarray, ds: float = 0.2) -> Lane:
    """Takes a numpy array of waypoints, resamples them, and computes metadata."""
    if len(waypoints) < 2:
        # Return an empty Lane object if not enough points
        return Lane(waypoints=np.array([]), meta={})

    # Resample points to a constant distance `ds`
    tck, u = splprep([waypoints[:, 0], waypoints[:, 1]], s=0, per=0)
    path_length = np.sum(np.sqrt(np.sum(np.diff(waypoints, axis=0)**2, axis=1)))
    num_points = int(np.ceil(path_length / ds))
    u_new = np.linspace(u.min(), u.max(), num_points)
    x_new, y_new = splev(u_new, tck)
    resampled_waypoints = np.vstack((x_new, y_new)).T

    # Calculate path length (s)
    distances = np.sqrt(np.sum(np.diff(resampled_waypoints, axis=0)**2, axis=1))
    s = np.concatenate(([0], np.cumsum(distances)))

    # Calculate tangents, normals, and curvature
    dx_dt = np.gradient(resampled_waypoints[:, 0], s)
    dy_dt = np.gradient(resampled_waypoints[:, 1], s)
    d2x_dt2 = np.gradient(dx_dt, s)
    d2y_dt2 = np.gradient(dy_dt, s)
    
    tangents = np.vstack((dx_dt, dy_dt)).T
    # Normalize tangents to get unit vectors
    tangent_norms = np.linalg.norm(tangents, axis=1).reshape(-1, 1)
    tangents = np.divide(tangents, tangent_norms, out=np.zeros_like(tangents), where=tangent_norms!=0)

    # Normals are perpendicular to tangents
    normals = np.vstack((-tangents[:, 1], tangents[:, 0])).T
    curvature = np.abs(d2x_dt2 * dy_dt - dx_dt * d2y_dt2) / (dx_dt**2 + dy_dt**2)**1.5

    meta = {
        "ds": ds,
        "s": s,
        "curvature": curvature,
        "tangents": tangents,
        "normals": normals
    }

    return Lane(waypoints=resampled_waypoints, meta=meta)

def _process_lane_from_file(file_path: str, ds: float = 0.2) -> Lane:
    """Loads waypoints from a CSV and processes them."""
    print(f"Processing lane from {file_path}...")
    df = pd.read_csv(file_path, header=None, usecols=[0, 1], names=['x', 'y'])
    waypoints = df[['x', 'y']].to_numpy()
    print(f"  Loaded {len(waypoints)} waypoints.")
    lane_obj = _calculate_lane_metadata(waypoints, ds)
    print(f"  Resampled to {len(lane_obj.waypoints)} waypoints (ds={ds}m).")
    return lane_obj

def load_three_lanes(center_csv: str, inner_csv: str, outer_csv: str, ds: float = 0.2, offset_ratio: float = 0.4) -> Lanes:
    """ 
    Loads a centerline and track boundaries, then generates three safe, drivable lanes.
    The 'inner' and 'outer' lanes are dynamically generated by offsetting from the centerline.
    """
    print("--- Loading centerline and boundaries ---")
    center_lane = _process_lane_from_file(center_csv, ds)
    inner_bound_pts = pd.read_csv(inner_csv, header=None, usecols=[0, 1], names=['x', 'y']).to_numpy()
    outer_bound_pts = pd.read_csv(outer_csv, header=None, usecols=[0, 1], names=['x', 'y']).to_numpy()

    print("--- Generating dynamic inner and outer lanes ---")
    new_inner_waypoints = []
    new_outer_waypoints = []

    center_points = center_lane.waypoints
    normals = center_lane.meta['normals']

    # Ensure normals point outwards. Check for the first point.
    # This assumes a counter-clockwise track. A more robust method might be needed for general cases.
    closest_inner_idx, _ = find_closest_waypoint(center_points[0], inner_bound_pts)
    vec_to_inner = inner_bound_pts[closest_inner_idx] - center_points[0]
    if np.dot(vec_to_inner, normals[0]) > 0:
        print("  Normal vectors seem to be pointing inwards. Flipping them.")
        normals = -normals

    for i in range(len(center_points)):
        center_pt = center_points[i]
        normal_vec = normals[i]

        # Find distance to inner and outer boundaries along the normal
        # This is a simplified approach; a ray-intersection method would be more robust.
        _, dist_to_inner = find_closest_waypoint(center_pt, inner_bound_pts)
        _, dist_to_outer = find_closest_waypoint(center_pt, outer_bound_pts)

        # Generate new points by offsetting from the center
        new_inner_pt = center_pt - normal_vec * dist_to_inner * offset_ratio
        new_outer_pt = center_pt + normal_vec * dist_to_outer * offset_ratio
        
        new_inner_waypoints.append(new_inner_pt)
        new_outer_waypoints.append(new_outer_pt)

    print(f"  Generated {len(new_inner_waypoints)} new inner and outer waypoints.")

    # Process the newly generated waypoints to get their metadata
    inner_lane = _calculate_lane_metadata(np.array(new_inner_waypoints), ds)
    outer_lane = _calculate_lane_metadata(np.array(new_outer_waypoints), ds)

    lanes = Lanes(
        center=center_lane,
        inner=inner_lane,
        outer=outer_lane,
    )
    print("--- All three drivable lanes are ready ---")
    return lanes
